---
layout: post
title: "[Python] 파이썬 클래스"
date: 2026-01-20
categories: [Python_Basic, Study]
tags: [python, class, object, oop, inheritance]
---
# 시작하기 전에..
클래스는 복잡한 프로그램을 아주 효율적으로 관리하게 해주는 강력한 무기입니다.

## 1. 클래스란 무엇이며, 왜 필요한가?

### 클래스란?
똑같은 무언가를 계속해서 만들어 낼 수 있는 설계도(틀)입니다.

### 왜 필요한가? (계산기 예시)
만약 계산기 2대가 필요하다고 가정해 봅시다. 각 계산기는 서로 다른 값을 기억하고 있어야 합니다.
* **클래스가 없다면:** `calculator1_add`, `calculator2_add` 처럼 변수와 함수를 계산기 개수만큼 계속 따로 만들어야 합니다.
* **클래스가 있다면:** '계산기'라는 설계도 하나만 있으면, `cal1`, `cal2`... `cal100`까지 객체만 생성하면 끝입니다. 각 객체는 서로의 값에 영향을 주지 않고 독립적으로 동작합니다.

## 2. 클래스와 객체 (Class vs Object)

가장 많이 비유하는 것이 **과자 틀**과 **과자**입니다.



|        구분        | 비유 (과자 틀) | 설명                                                     |
| :----------------: | :------------- | :------------------------------------------------------- |
| **클래스 (Class)** | 과자 틀        | 객체를 찍어내기 위한 설계도                              |
| **객체 (Object)**  | 찍혀 나온 과자 | 클래스로 만든 피조물. (파이썬에서는 '인스턴스'라고도 함) |

> **용어 팁:** `a = Cookie()` 이렇게 만들었을 때, `a`는 **객체**입니다. 그리고 `a`는 `Cookie`의 **인스턴스**입니다. (거의 같은 말입니다.)

## 3. 사칙연산 클래스 만들기 (`FourCal`)

클래스를 만드는 가장 좋은 방법은 **"어떻게 사용할지"**를 먼저 구상하는 것입니다.

### ① 클래스 구상하기

|     기능      | 메서드(함수) 이름 | 설명                       |
| :-----------: | :---------------- | :------------------------- |
| **숫자 설정** | `setdata`         | 연산할 숫자 2개를 입력받음 |
|  **더하기**   | `add`             | 두 수를 더함               |
|   **빼기**    | `sub`             | 두 수를 뺌                 |
|  **곱하기**   | `mul`             | 두 수를 곱함               |
|  **나누기**   | `div`             | 두 수를 나눔               |

### ② 클래스 구조 만들기
가장 기본적인 껍데기를 만듭니다.

```python
class FourCal:
    pass

```

### ③ 객체에 연산할 숫자 지정하기 (`setdata`)

가장 중요한 개념인 **`self`**가 등장합니다.

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second

a = FourCal()
a.setdata(4, 2)

```

* **`self`란?**: 메서드를 호출한 **객체 자기 자신(`a`)**을 의미합니다.
* `a.setdata(4, 2)`를 호출하면 `self`에는 `a`가 전달됩니다. 결과적으로 `a.first = 4`가 됩니다.

> **(참고) 메서드를 호출하는 또 다른 방법**
> * `a.setdata(4, 2)` (일반적인 방법)
> * `FourCal.setdata(a, 4, 2)` (클래스 이름으로 호출 시 객체 `a`를 첫 번째 인자로 꼭 넣어줘야 함)
> 
> 

### ④ 더하기, 빼기, 곱하기, 나누기 기능 만들기

```python
class FourCal:
    def setdata(self, first, second):
        self.first = first
        self.second = second
    
    def add(self):
        return self.first + self.second
    
    def sub(self):
        return self.first - self.second

    def mul(self):
        return self.first * self.second

    def div(self):
        return self.first / self.second

```

**사용해보기:**

```python
a = FourCal()
a.setdata(4, 2)
print(a.add()) # 6
print(a.div()) # 2.0

```

## 4. 생성자 (Constructor)

위 코드의 단점은 `setdata`를 실행하지 않고 `add`를 호출하면 에러가 난다는 것입니다.
객체를 생성함과 **동시에** 값을 설정하고 싶을 때 **생성자(`__init__`)**를 사용합니다.

```python
class FourCal:
    def __init__(self, first, second): # 메서드 이름이 __init__
        self.first = first
        self.second = second
    
    def add(self):
        result = self.first + self.second
        return result
    # ... 나머지 생략 ...

# 사용법
a = FourCal(4, 2) # 생성 때 값을 던져줌 (setdata 필요 없음!)
print(a.add())

```

## 5. 클래스의 상속 (Inheritance)

### 상속이란?

기존 클래스(`FourCal`)의 기능을 물려받아 새로운 클래스를 만드는 것입니다.

### 상속은 왜 쓰는 걸까?

1. 기존 클래스를 변경하지 않고 기능을 추가하거나 수정하고 싶을 때.
2. 기존 클래스가 라이브러리 형태라 수정할 수 없을 때.

### 예제: 제곱 기능 추가하기 (`MoreFourCal`)

```python
class MoreFourCal(FourCal): # 괄호 안에 상속받을 클래스 이름 넣기
    def pow(self):
        return self.first ** self.second

a = MoreFourCal(4, 2)
print(a.add()) # 6 (부모의 기능 사용 가능)
print(a.pow()) # 16 (자식의 기능)

```

## 6. 메서드 오버라이딩 (Overriding)

부모 클래스의 기능을 자식 클래스에서 **덮어쓰기(재정의)** 하는 것입니다.

**상황:** `FourCal`은 0으로 나누면 에러가 납니다.
**해결:** `SafeFourCal`을 만들어 나누기(`div`) 메서드만 수정해 봅시다.

```python
class SafeFourCal(FourCal):
    def div(self):  # 부모의 div를 덮어씀
        if self.second == 0:
            return 0
        else:
            return self.first / self.second

a = SafeFourCal(4, 0)
print(a.div()) # 에러 대신 0 출력

```

## 7. 클래스 변수

객체 변수(`self.first`)는 객체마다 다른 값을 가지지만, **클래스 변수**는 모든 객체가 **값을 공유**합니다.

```python
class Family:
    lastname = "김"  # 클래스 변수 선언

a = Family()
b = Family()
print(a.lastname) # 김
print(b.lastname) # 김

Family.lastname = "박" # 클래스 변수 변경
print(a.lastname) # 박 (모두 바뀜)
print(b.lastname) # 박

```

### 주의: 클래스 변수와 동일한 이름의 객체 변수를 생성하면?

```python
a.lastname = "최" # 객체 a에 새로운 객체 변수 lastname을 생성함

print(Family.lastname) # 박 (클래스 변수는 그대로)
print(a.lastname)      # 최 (a의 객체 변수가 우선)
print(b.lastname)      # 박 (b는 여전히 클래스 변수를 바라봄)

```

> **결론:** 객체 변수는 클래스 변수보다 우선순위가 높으며, 서로 영향을 주지 않게 분리됩니다.