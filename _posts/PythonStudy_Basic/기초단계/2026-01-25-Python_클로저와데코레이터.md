---
layout: post
title: "[Python] 파이썬 클로저와 데코레이터"
date: 2026-01-25
categories: [Python_Basic, Study]
tags: [python, closure, decorator, args, kwargs]
---
# 시작하기 전에..
파이썬 코드를 보다 보면 함수 위에 `@` 기호가 붙어 있는 것을 종종 볼 수 있습니다. 이것이 바로 **데코레이터**입니다.
이 데코레이터를 이해하기 위해서는 먼저 **`*args`, `**kwargs`**와 **클로저**라는 개념을 잡고 넘어가야 합니다. 차근차근 알아봅시다.

---

## 1. 기초 다지기: `*args`와 `**kwargs`

함수를 만들 때 인수의 개수가 몇 개가 될지 모른다면 어떻게 해야 할까요? 이때 사용하는 것이 가변 인자입니다.

### `*args` (Arguments)
* 여러 개의 입력값을 **튜플(Tuple)**로 받습니다.
* 이름 앞에 별 하나(`*`)를 붙입니다.

### `**kwargs` (Keyword Arguments)
* `key=value` 형태의 입력값을 **딕셔너리(Dictionary)**로 받습니다.
* 이름 앞에 별 두 개(`**`)를 붙입니다.

```python
def print_args(*args, **kwargs):
    print("args:", args)
    print("kwargs:", kwargs)

print_args(1, 2, 3, name="홍길동", age=30)

```

**결과:**

```text
args: (1, 2, 3)
kwargs: {'name': '홍길동', 'age': 30}

```

> **팁:** 변수명(`args`, `kwargs`)은 관례일 뿐, `*a`, `**k`처럼 써도 되지만, 관례를 따르는 것이 좋습니다.

---

## 2. 클로저 (Closure)

### 클로저란?

함수 안에 **내부 함수(Inner Function)**를 구현하고, 그 내부 함수를 **반환(Return)**하는 함수를 말합니다.
이때 내부 함수는 **외부 함수의 변수(free variable)를 기억**하고 있다는 것이 핵심입니다.

### 왜 사용할까?

외부 함수가 종료되어 메모리에서 사라져도, 내부 함수가 외부 함수의 변수 값을 꽉 붙들고 있기 때문에 **데이터를 감추거나(은닉), 상태를 유지**하고 싶을 때 사용합니다.

### 클로저 구조 만들기

```python
def mul(m):           # 외부 함수
    def wrapper(n):   # 내부 함수
        return m * n  # 외부 함수의 변수 m을 사용 (기억함)
    return wrapper    # 내부 함수 자체를 리턴 (괄호 없음 주의!)

# 사용
mul3 = mul(3)    # m=3인 상태의 wrapper 함수가 mul3에 저장됨
mul5 = mul(5)    # m=5인 상태의 wrapper 함수가 mul5에 저장됨

print(mul3(10))  # 30 (3 * 10)
print(mul5(10))  # 50 (5 * 10)

```

* `mul(3)` 호출이 끝나도 `mul3`는 `m=3`이라는 사실을 기억하고 있습니다. 이것이 클로저입니다.

---

## 3. 데코레이터 (Decorator)

### 데코레이터란?

**"기존 함수를 바꾸지 않고 기능을 추가하고 싶을 때"** 사용하는 디자인 패턴입니다.
클로저를 활용하여, 함수를 선물 포장하듯이 감싸는(Wrap) 방식입니다.

### 상황 예시

어떤 함수가 실행될 때마다 "실행 시작", "실행 끝"을 출력하고 싶습니다. 모든 함수에 `print` 문을 넣는 건 너무 번거롭겠죠?

### 데코레이터 만들기 (기본형)

```python
import time

def time_checker(func):    # 데코레이터 함수 (인자로 함수를 받음)
    def wrapper():
        print(f"--- {func.__name__} 시작 ---")
        start_time = time.time()
        
        func()             # 받아온 원래 함수를 실행
        
        end_time = time.time()
        print(f"--- 종료 (걸린 시간: {end_time - start_time:.2f}초) ---")
    return wrapper

```

### 데코레이터 적용하기 (`@` 사용)

**방법 1: 정석적인 방법 (잘 안 씀)**

```python
def my_func():
    print("함수 실행 중...")

my_func = time_checker(my_func) # 함수를 데코레이터에 넣어서 다시 할당
my_func()

```

**방법 2: `@` 문법 사용 (추천 ⭐)**

```python
@time_checker
def my_func():
    time.sleep(1) # 1초 대기
    print("함수 실행 중...")

my_func()

```

**실행 결과:**

```text
--- my_func 시작 ---
함수 실행 중...
--- 종료 (걸린 시간: 1.00초) ---

```

---

## 4. 만능 데코레이터 만들기 (인수가 있는 함수용)

위의 `time_checker`는 인수가 없는 함수(`my_func()`)에만 쓸 수 있습니다.
인수가 있든 없든 다 처리하려면 처음에 배운 `*args`, `**kwargs`를 사용합니다.

```python
def trace(func):                             # 1. 데코레이터 함수
    def wrapper(*args, **kwargs):            # 2. 어떤 인수가 오든 다 받음
        print(f"{func.__name__} 함수 실행 전")
        
        result = func(*args, **kwargs)       # 3. 받은 인수를 그대로 넘겨서 실행
        
        print(f"{func.__name__} 함수 실행 후")
        return result                        # 4. 함수의 리턴값도 챙겨서 돌려줌
    return wrapper

@trace
def add(a, b):
    return a + b

print(add(10, 20))

```

### 요약

1. **`*args`, `**kwargs**`: 어떤 형태의 인수든 받아서 전달할 때 쓴다.
2. **클로저**: 외부 함수의 변수를 기억하는 내부 함수를 리턴하는 구조다.
3. **데코레이터**: 클로저를 응용하여, **함수 앞뒤에 기능을 덧붙이는(Decorate)** 편리한 문법(`@`)이다.
