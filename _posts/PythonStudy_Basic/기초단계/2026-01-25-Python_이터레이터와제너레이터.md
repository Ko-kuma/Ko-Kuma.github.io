---
layout: post
title: "[Python] 이터레이터와 제너레이터"
date: 2026-01-25
categories: [Python_Basic, Study]
tags: [python, iterator, generator, yield, lazy_evaluation]
---
# 시작하기 전에..
리스트에 1억 개의 숫자를 담으면 어떻게 될까? 아마 컴퓨터 메모리가 가득 차서 프로그램이 멈출 것입니다.
하지만 **제너레이터**를 쓰면 1억 개, 아니 무한대의 숫자도 아주 적은 메모리로 다룰 수 있습니다. 파이썬의 **반복(Iteration)** 원리를 파헤쳐 봅니다.

---

## 1. 이터레이터(Iterator)란?

### 반복 가능한 객체 (Iterable) vs 이터레이터 (Iterator)
* **Iterable (반복 가능한 객체):** 리스트, 튜플, 문자열처럼 `for` 문을 돌릴 수 있는 객체입니다. 내부에 `__iter__` 메서드가 있습니다.
* **Iterator (이터레이터):** `next()` 함수를 호출할 때마다 **값을 하나씩 꺼내주는 객체**입니다. `__next__` 메서드가 있습니다.

> **쉽게 이해하기:**
> * **Iterable:** 자판기 (상품이 들어있음)
> * **Iterator:** 자판기 버튼 (누를 때마다 하나씩 나옴)

### 이터레이터 만들기 (클래스)
직접 `__iter__`와 `__next__`를 구현하여 이터레이터를 만들어 봅시다.

```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index < len(self.data):
            result = self.data[self.index]
            self.index += 1
            return result
        else:
            raise StopIteration # 더 이상 꺼낼 게 없으면 예외 발생

# 사용하기
it = MyIterator([1, 2, 3])
print(next(it)) # 1
print(next(it)) # 2
print(next(it)) # 3
# print(next(it)) # StopIteration 에러 발생

```

---

## 2. 제너레이터(Generator)란?

이터레이터를 클래스로 만들려니 코드가 너무 길고 복잡하죠?
**제너레이터**는 이터레이터를 아주 간편하게 만들 수 있는 **함수**입니다. 핵심은 `return` 대신 **`yield`**를 쓴다는 점입니다.

### 제너레이터 만들기 (`yield`)

```python
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
print(type(gen)) # <class 'generator'>

print(next(gen)) # 1
print(next(gen)) # 2
print(next(gen)) # 3

```

### 동작 원리 (Lazy Evaluation)

* `yield`를 만나면 **값을 전달하고 잠시 멈춥니다(Pause).**
* 다음에 `next()`가 호출되면 멈췄던 그 자리에서 다시 시작합니다.
* **지연 평가(Lazy Evaluation):** 미리 다 만들어두지 않고, **필요할 때마다 하나씩** 만듭니다. 그래서 메모리를 거의 쓰지 않습니다.

---

## 3. 제너레이터 표현식 (Generator Expression)

리스트 컴프리헨션과 비슷하지만, 대괄호 `[]` 대신 소괄호 `()`를 사용합니다.

```python
# 리스트 컴프리헨션: 이미 0~9까지의 모든 숫자를 메모리에 올림
my_list = [i for i in range(10)]

# 제너레이터 표현식: 아직 숫자를 안 만듬. next() 부를 때마다 생성
my_gen = (i for i in range(10))

print(my_list) # [0, 1, 2, ... 9]
print(my_gen)  # <generator object ... at 0x...>

```

---

## 4. 제너레이터 vs 이터레이터

사실 **제너레이터는 이터레이터의 한 종류**입니다. 하지만 구현 방식과 편의성에서 차이가 있습니다.

| 구분            | 이터레이터 (Iterator)          | 제너레이터 (Generator)                   |
| --------------- | ------------------------------ | ---------------------------------------- |
| **구현 방법**   | `class` 정의 (`__next__` 구현) | `def` 함수 정의 (`yield` 사용)           |
| **생성 난이도** | 복잡함                         | 매우 간단함                              |
| **메모리 효율** | 좋음                           | **매우 좋음**                            |
| **특징**        | `next()`로 호출 가능           | `next()`로 호출 가능 (이터레이터의 일종) |

---

## 5. 제너레이터 활용하기 (메모리 절약 예제)

### 상황: 엄청나게 큰 데이터 처리하기

만약 1초부터 무한대까지 시간을 재는 함수가 필요하다면 리스트로는 불가능합니다. 제너레이터라면 가능합니다.

```python
import time

def infinite_timer():
    seconds = 0
    while True: # 무한 루프지만 괜찮음!
        yield seconds
        seconds += 1
        time.sleep(1) # 1초 대기

timer = infinite_timer()

# 필요할 때마다 하나씩 꺼내 씀
print(next(timer)) # 0
print(next(timer)) # 1
print(next(timer)) # 2

```

### 메모리 사용량 비교

```python
import sys

# 리스트: 100만 개를 미리 만듦 -> 메모리 많이 차지
list_data = [i for i in range(1000000)]
print(sys.getsizeof(list_data)) # 약 8MB (8,448,728 bytes)

# 제너레이터: 생성 규칙만 기억함 -> 메모리 아주 적음
gen_data = (i for i in range(1000000))
print(sys.getsizeof(gen_data))  # 약 100 바이트 (112 bytes)

```

---

### 요약

1. **이터레이터**: `next()`로 값을 하나씩 꺼내는 객체.
2. **제너레이터**: `yield`를 사용해 이터레이터를 쉽게 만드는 함수.
3. **장점**: **필요할 때만 값을 생성(Lazy Evaluation)**하므로 메모리를 효율적으로 사용하며, 무한한 데이터를 다룰 수 있다.
