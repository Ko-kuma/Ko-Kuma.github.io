---
layout: post
title: "[Python] 정규표현식"
date: 2026-01-26
categories: [Python_Basic, Study]
tags: [python, regex, re, pattern_matching, text_processing]
---
# 시작하기 전에..
문자열을 다룰 때, 단순히 `find`나 `split`만으로는 해결되지 않는 복잡한 상황들이 있습니다.
"주민등록번호 뒷자리를 *로 가려줘", "이메일 주소만 추출해줘" 같은 요구사항을 한 줄의 코드로 해결해 주는 강력한 도구, **정규표현식**에 대해 깊이 있게 알아봅니다.

---

## 1. 정규표현식 개요

### 정규표현식이란?
복잡한 문자열을 처리할 때 사용하는 기법으로, 특정한 규칙을 가진 문자열의 집합을 표현하는 형식 언어입니다.

### 왜 필요한가?
* **효율성:** 수십 줄의 조건문(`if`, `for`)을 단 몇 줄의 정규식으로 대체할 수 있습니다.
* **강력함:** 이메일 검증, 로그 파일 분석, 개인정보 마스킹 등 패턴이 있는 문자열 처리에 최적화되어 있습니다.

---

## 2. 기초 메타 문자 (Meta Characters)

메타 문자란 원래 그 문자가 가진 뜻이 아니라, 특별한 용도로 사용되는 문자를 말합니다.

### 2-1. 문자 클래스 `[]`
`[ ]` 사이의 문자들 중 **하나**와 매치된다는 뜻입니다.

| 표현식   | 의미                | 예시        | 매치 O     | 매치 X |
| :------- | :------------------ | :---------- | :--------- | :----- |
| `[abc]`  | a, b, c 중 하나     | `before`    | 'b'가 있음 | `dude` |
| `[a-z]`  | 소문자 전체 (범위)  | `python`    | -          | `123`  |
| `[0-9]`  | 숫자 전체           | `Year 2026` | -          | `Test` |
| `[^0-9]` | 숫자 **제외** (Not) | `Test`      | -          | `123`  |

### 2-2. 자주 사용하는 문자 클래스 (별명)

|  표현식  | 설명                          |   동일한 표현    |
| :------: | :---------------------------- | :--------------: |
| **`\d`** | 숫자 (Digit)                  |     `[0-9]`      |
| **`\D`** | 숫자 아님                     |     `[^0-9]`     |
| **`\s`** | 공백 문자 (Space, Tab, Enter) | `[ \t\n\r\f\v]`  |
| **`\S`** | 공백 아님                     | `[^ \t\n\r\f\v]` |
| **`\w`** | 문자+숫자 (Word)              |  `[a-zA-Z0-9_]`  |
| **`\W`** | 문자+숫자 아님                | `[^a-zA-Z0-9_]`  |

### 2-3. Dot `.` 문자
줄바꿈 문자(`\n`)를 제외한 **모든 문자**와 매치됩니다.
* `a.b` $\rightarrow$ `a` + 모든문자 + `b` (`aab`, `a0b` 가능 / `abc` 불가능)

### 2-4. 반복 관련 메타 문자 (`*`, `+`, `{}`, `?`)

|     문자     |     의미      | 설명                   | 예시 (`ca*t`)                           |
| :----------: | :-----------: | :--------------------- | :-------------------------------------- |
|   **`*`**    | 0번 이상 반복 | 없어도 되고 많아도 됨  | `ct`, `cat`, `caaat`                    |
|   **`+`**    | 1번 이상 반복 | 최소 한 번은 있어야 함 | `cat`, `caaat` (O) / `ct` (X)           |
|   **`?`**    | 0번 또는 1번  | 있거나 없거나          | `ct`, `cat` (O) / `caat` (X)            |
|  **`{m}`**   |  정확히 m번   | 고정 반복              | `ca{2}t` $\rightarrow$ `caat`           |
| **`{m, n}`** |   m번 ~ n번   | 범위 반복              | `ca{1,3}t` $\rightarrow$ `cat`, `caaat` |

---

## 3. 파이썬 `re` 모듈과 문자열 검색

파이썬은 정규표현식을 지원하기 위해 `re` (regular expression) 모듈을 제공합니다.

### 3-1. 검색 메서드 4총사



| 메서드           | 설명                                           | 반환값               |
| :--------------- | :--------------------------------------------- | :------------------- |
| **`match()`**    | 문자열의 **처음부터** 정규식과 매치되는지 조사 | match 객체 또는 None |
| **`search()`**   | 문자열 **전체**를 검색하여 매치되는지 조사     | match 객체 또는 None |
| **`findall()`**  | 매치되는 모든 문자열을 **리스트**로 리턴       | 리스트 `['a', 'b']`  |
| **`finditer()`** | 매치되는 모든 문자열을 **iterator**로 리턴     | iterator 객체        |

### 3-2. `match` 객체의 메서드
`match()`나 `search()`가 성공하면 반환되는 객체에서 정보를 꺼낼 때 씁니다.

```python
import re
p = re.compile('[a-z]+')
m = p.search("3 python") 

print(m.group()) # python (매치된 문자열)
print(m.start()) # 2 (매치 시작 인덱스)
print(m.end())   # 8 (매치 끝 인덱스)
print(m.span())  # (2, 8) (튜플 형태)

```

### 3-3. 모듈 단위 수행 vs 컴파일

* **컴파일:** `p = re.compile('정규식')`  `p.search(...)` (반복 사용 시 효율적)
* **모듈 단위:** `re.search('정규식', ...)` (한 번만 쓸 때 간편)

---

## 4. 컴파일 옵션 (Flags)

정규식을 컴파일할 때 특별한 옵션을 줄 수 있습니다.

| 옵션 (약어)            | 설명                                               |
| ---------------------- | -------------------------------------------------- |
| **`DOTALL` (`S`)**     | `.` 메타 문자가 줄바꿈(`\n`)까지 포함하도록 함     |
| **`IGNORECASE` (`I`)** | 대소문자를 구별하지 않음                           |
| **`MULTILINE` (`M`)**  | `^`, `$` 메타 문자를 각 줄마다 적용함              |
| **`VERBOSE` (`X`)**    | 정규식을 보기 좋게 줄바꿈하고 주석을 달 수 있게 함 |

---

## 5. 백슬래시(`\`) 문제와 Raw String

정규식에서 `\section`을 찾으려는데 파이썬이 `\s`를 공백 문자로 해석해 버리면 꼬이게 됩니다.
이를 방지하기 위해 파이썬 문자열 앞에 `r`을 붙입니다.

* `p = re.compile(r'\\section')`

---

## 6. 문자열 소비가 없는 메타 문자 (Zero-width Assertions)

실제로 문자를 검색하지만, 결과에는 포함되지 않거나 위치만 확인하는 문자들입니다.

| 메타 문자 | 설명                                              | 예시        |
| --------- | ------------------------------------------------- | ----------- |
| **`       | `**                                               | OR (또는)   |
| **`^`**   | 문자열의 맨 처음                                  | `^Life`     |
| **`$`**   | 문자열의 맨 끝                                    | `short$`    |
| **`\A`**  | 문자열의 맨 처음 (MULTILINE 모드여도 전체의 처음) | -           |
| **`\Z`**  | 문자열의 맨 끝 (MULTILINE 모드여도 전체의 끝)     | -           |
| **`\b`**  | 단어 경계 (공백 등으로 구분된 단어)               | `\bclass\b` |
| **`\B`**  | 단어 경계가 아님 (글자 사이에 끼인 것)            | `\Bclass\B` |

---

## 7. 그루핑 (Grouping)

특정 문자열이 계속 반복되는지 조사하거나, 매치된 문자열 중 특정 부분만 뽑아내고 싶을 때 `()`를 사용합니다.

### 7-1. 그룹핑과 재참조 (`\1`)

```python
p = re.compile(r'(\w+)\s+\1') # 같은 단어가 연속 두 번 나오는지?
m = p.search('Paris in the the spring')
print(m.group()) # the the

```

* `\1`: 첫 번째 그룹과 동일한 문자열이 와야 함을 의미

### 7-2. 그루핑된 문자열에 이름 붙이기

인덱스 대신 이름으로 그룹을 찾을 수 있습니다. `(?P<이름>...)` 형식을 씁니다.

```python
p = re.compile(r"(?P<name>\w+)\s+(?P<phone>\d+)")
m = p.search("park 01012341234")
print(m.group("name")) # park

```

---

## 8. 전방 탐색 (Lookahead)

정규식 안에서 소모(consume)되지 않고 뒤에 오는 내용만 확인하고 싶을 때 사용합니다.

### 8-1. 긍정형 전방 탐색 `(?=...)`

검색 조건에는 포함되지만 결과 문자열에는 포함되지 않습니다.

```python
p = re.compile(".+(?=:)") # : 뒤에 오는 건 확인만 하고 결과에선 뺌
m = p.search("[http://google.com](http://google.com)")
print(m.group()) # http (':'는 제외됨)

```

### 8-2. 부정형 전방 탐색 `(?!...)`

특정 문자가 뒤에 오지 **않는** 경우만 매치합니다.

* `.*[.](?!bat$|exe$).*$` : 확장자가 bat이나 exe가 아닌 파일만 매치

---

## 9. 문자열 바꾸기 (`sub`)

매치된 부분을 다른 문자열로 치환할 때 사용합니다.

### 9-1. `sub`와 `subn`

* **`sub(바꿀문자, 대상문자열)`**: 바뀐 문자열 반환
* **`subn`**: `(바뀐문자열, 바뀐횟수)` 튜플 반환

```python
p = re.compile('(blue|white|red)')
print(p.sub('colour', 'blue socks and red shoes'))
# colour socks and colour shoes

```

### 9-2. 참조 구문 사용하기 (`\g`)

바꿀 문자열 안에서 그룹을 참조할 수 있습니다.

```python
p = re.compile(r"(?P<name>\w+)\s+(?P<phone>\d+)")
# 이름과 전화번호 순서를 바꿈 (\g<2> \g<1>)
print(p.sub("\g<phone> \g<name>", "park 01012345678"))
# 01012345678 park

```

### 9-3. `sub` 메서드의 매개변수로 함수 넣기

단순 문자열 치환이 아니라, 복잡한 로직으로 치환하고 싶을 때 함수를 넣을 수 있습니다.

```python
def hexrepl(match):
    # 매치된 숫자를 16진수로 변환하는 함수
    value = int(match.group())
    return hex(value)

p = re.compile(r'\d+')
print(p.sub(hexrepl, 'Call 65490 for printing, 49152 for user code.'))

```

---

## 10. Greedy vs Non-Greedy

정규식의 반복(`*`, `+`)은 기본적으로 **탐욕적(Greedy)**입니다. 가능한 한 가장 길게 매치하려고 합니다.

### 탐욕적 (Greedy)

```python
s = '<html><head><title>Title</title>'
print(re.match('<.*>', s).group())
# <html><head><title>Title</title> (전체를 다 먹어버림)

```

### 비탐욕적 (Non-Greedy) `?`

반복 메타 문자 뒤에 `?`를 붙이면 **가장 최소한**으로 매치합니다.

```python
print(re.match('<.*?>', s).group())
# <html> (가장 먼저 닫히는 > 까지만 매치)

```

| 탐욕적  | 비탐욕적 | 설명                 |
| ------- | -------- | -------------------- |
| `*`     | `*?`     | 최소한(0번)으로 반복 |
| `+`     | `+?`     | 최소한(1번)으로 반복 |
| `{m,n}` | `{m,n}?` | 가능한 적게 반복     |

```

```