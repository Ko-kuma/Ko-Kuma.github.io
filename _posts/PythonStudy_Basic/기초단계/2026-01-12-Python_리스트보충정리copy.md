---
layout: post
title: "[Python] 리스트 보충정리, copy 모듈 (얕은 복사 vs 깊은 복사)"
date: 2026-01-12
categories: [Python_Basic, Study]
tags: [python, list, copy, memory, deepcopy]
---
# 시작하기 전에..
리스트를 공부할 때 가장 많이 실수하는 부분, 바로 **'복사'**입니다.
단순히 변수만 다른 것에 할당한다고 해서 새로운 리스트가 생기는 것이 아닙니다. 파이썬의 `copy` 모듈을 통해 안전하게 데이터를 복사하는 방법을 알아봅니다.

## 1. 그냥 할당하기 (Assignment) - "이름표만 하나 더 붙임"

리스트 `a`를 `b`에 할당(`=`)하면 어떻게 될까요?

```python
a = [1, 2, 3]
b = a

b[0] = 99

print(a) # [99, 2, 3]  <- a도 바뀌어버림!
print(b) # [99, 2, 3]

```

* **이유:** `b = a`는 값을 복사하는 것이 아니라, `a`가 가리키는 **메모리 주소**를 `b`도 같이 가리키게 하는 것입니다. 즉, 객체는 하나이고 이름표만 두 개(a, b)인 상태입니다.

## 2. 얕은 복사 (Shallow Copy) - "껍데기만 복사"

리스트의 슬라이싱(`[:]`)이나 `copy()` 메서드, 혹은 `copy` 모듈을 사용하면 **새로운 리스트 객체**를 만들 수 있습니다.

```python
import copy

a = [1, 2, 3]
b = copy.copy(a)  # 또는 b = a[:]

b[0] = 99

print(a) # [1, 2, 3]   <- a는 안전함
print(b) # [99, 2, 3]

```

* **성공?** 1차원 리스트(숫자나 문자열만 있는 경우)에서는 완벽하게 분리됩니다.
* **문제점:** 하지만 리스트 안에 **또 다른 리스트(이중 리스트)**가 있다면 문제가 발생합니다.

### 얕은 복사의 함정 (이중 리스트)

```python
a = [[1, 2], [3, 4]]
b = copy.copy(a)

b[0][0] = 99

print(a) # [[99, 2], [3, 4]] <- 헉! 내부 리스트는 또 같이 바뀜
print(b) # [[99, 2], [3, 4]]

```

* **이유:** 겉의 리스트(껍데기)는 새로 만들었지만, 그 안에 들어있는 내부 리스트 `[1, 2]`는 여전히 **같은 주소**를 공유하기 때문입니다.

## 3. 깊은 복사 (Deep Copy) - "영혼까지 복사"

리스트 안에 리스트가 있든, 딕셔너리가 있든 **완벽하게 독립적인 복사본**을 만들고 싶다면 `copy` 모듈의 `deepcopy`를 써야 합니다.

```python
import copy

a = [[1, 2], [3, 4]]
b = copy.deepcopy(a) # 깊은 복사 사용

b[0][0] = 99

print(a) # [[1, 2], [3, 4]]  <- 원본 a는 전혀 영향을 받지 않음!
print(b) # [[99, 2], [3, 4]] <- b만 변경됨

```

* **원리:** 내부의 객체들까지 재귀적으로 찾아가며 모두 새롭게 복사해 냅니다.

---

### 이해하기

| 구분                 | 사용법                     | 특징                               | 비유                                       |
| -------------------- | -------------------------- | ---------------------------------- | ------------------------------------------ |
| **할당(Assignment)** | `b = a`                    | 주소 공유 (완전 일치)              | 방 열쇠를 복사해 줌 (같은 방 공유)         |
| **얕은 복사**        | `a[:]` 또는 `copy.copy(a)` | 겉만 복사, 내부 객체는 공유        | 방은 따로 잡았는데, 가구는 같이 씀         |
| **깊은 복사**        | `copy.deepcopy(a)`         | 겉과 속 모두 새로 생성 (완전 분리) | 방도 따로 잡고, 가구도 똑같은 걸로 새로 삼 |

> **결론:** 일반적인 1차원 리스트는 `[:]`로 충분하지만, **2차원 이상의 복잡한 리스트**를 원본 훼손 없이 다루려면 반드시 **`copy.deepcopy()`**를 사용하세요!