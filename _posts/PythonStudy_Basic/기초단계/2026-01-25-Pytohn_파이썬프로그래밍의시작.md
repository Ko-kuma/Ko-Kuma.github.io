---
layout: post
title: "[Python] 파이썬을 활용한 간단한 프로젝트"
date: 2026-01-26
categories: [Python_Basic, Study]
tags: [python, algorithm, os, sys, pagination]
---

## 1. 3과 5의 배수 합하기 (알고리즘 기초)

**문제:** 1000 미만의 자연수 중 3의 배수이거나 5의 배수인 숫자들의 합을 구하시오.

### 생각의 흐름
1.  1부터 999까지 숫자를 반복한다. (`range`, `for`)
2.  숫자가 3의 배수인지 확인한다. (`% 3 == 0`)
3.  숫자가 5의 배수인지 확인한다. (`% 5 == 0`)
4.  두 조건 중 하나라도 만족하면(`or`) 더한다.

### 코드 구현
```python
result = 0
for n in range(1, 1000):
    if n % 3 == 0 or n % 5 == 0:
        result += n
print(result) # 결과: 233168

```

> **핵심:** `or` 연산자를 사용하면 15와 같이 3과 5의 공배수가 중복되어 더해지는 것을 방지할 수 있습니다.

---

## 2. 게시판 페이징하기 (수학적 로직)

**문제:** 게시물의 총 건수(`m`)와 한 페이지에 보여줄 게시물 수(`n`)가 주어졌을 때, **총 페이지 수**를 구하는 함수를 작성하시오.

### 생각의 흐름 (경우의 수 나누기)

| 총 건수 (m) | 페이지당 (n) | 계산         | 총 페이지 수 | 설명                             |
| ----------- | ------------ | ------------ | ------------ | -------------------------------- |
| **5**       | 10           | 5 // 10 = 0  | **1**        | 나머지가 있으므로 +1 페이지 필요 |
| **10**      | 10           | 10 // 10 = 1 | **1**        | 딱 떨어짐                        |
| **15**      | 10           | 15 // 10 = 1 | **2**        | 나머지가 있으므로 +1 페이지 필요 |
| **30**      | 10           | 30 // 10 = 3 | **3**        | 딱 떨어짐                        |

### 코드 구현

```python
def get_total_page(m, n):
    if m % n == 0:
        return m // n
    else:
        return m // n + 1

print(get_total_page(5, 10))  # 1
print(get_total_page(15, 10)) # 2
print(get_total_page(25, 10)) # 3
print(get_total_page(30, 10)) # 3

```

---

## 3. 간단한 메모장 만들기 (sys.argv, 파일 입출력)

**문제:** 터미널에서 실행 옵션에 따라 메모를 저장하거나 조회하는 프로그램을 만드시오.

* 저장: `python memo.py -a "메모내용"`
* 조회: `python memo.py -v`

### 생각의 흐름

1. **입력:** `sys.argv`를 이용해 옵션과 내용을 받는다.
2. **저장 로직 (`-a`):** 파일 모드 `'a'`(append)를 사용하여 기존 내용 뒤에 추가한다.
3. **조회 로직 (`-v`):** 파일 모드 `'r'`(read)을 사용하여 내용을 읽고 출력한다.

### 코드 구현 (`memo.py`)

```python
import sys

# sys.argv[0]은 파일명(memo.py)이므로 [1]부터 확인
option = sys.argv[1]

if option == '-a':
    memo = sys.argv[2]
    f = open('memo.txt', 'a')
    f.write(memo)
    f.write('\n') # 줄바꿈 추가
    f.close()
elif option == '-v':
    f = open('memo.txt', 'r')
    memo = f.read()
    f.close()
    print(memo)

```

---

## 4. 탭 문자를 공백 문자 4개로 바꾸기 (문자열 처리)

**문제:** 소스 코드(`src.txt`) 내의 탭(`\t`) 문자를 공백 4개(`        `)로 변환하여 다른 파일(`dst.txt`)로 저장하시오.

* 실행: `python tabto4.py src.txt dst.txt`

### 생각의 흐름

1. `sys.argv`로 입력 파일명과 출력 파일명을 받는다.
2. 입력 파일을 읽는다 (`read`).
3. 문자열 함수 `.replace("\t", "    ")`를 사용한다.
4. 변환된 내용을 출력 파일에 쓴다 (`write`).

### 코드 구현 (`tabto4.py`)

```python
import sys

src = sys.argv[1]
dst = sys.argv[2]

f = open(src)
tab_content = f.read()
f.close()

space_content = tab_content.replace("\t", " " * 4)

f = open(dst, 'w')
f.write(space_content)
f.close()

```

---

## 5. 하위 디렉터리 검색하기 (재귀 함수)

**문제:** 특정 디렉터리부터 시작하여 그 하위의 모든 디렉터리를 탐색하며 `.py` 파일만 출력하시오.

### 생각의 흐름

1. `os.listdir`로 파일 목록을 가져온다.
2. `os.path.join`으로 전체 경로를 만든다.
3. `os.path.isdir`로 디렉터리인지 파일인지 구분한다.
4. **디렉터리라면?**  자기 자신을 다시 호출한다 (**재귀 함수**).
5. **파일이라면?**  확장자가 `.py`인지 확인하고 출력한다.

### 코드 구현

```python
import os

def search(dirname):
    try:
        filenames = os.listdir(dirname)
        for filename in filenames:
            full_filename = os.path.join(dirname, filename)
            if os.path.isdir(full_filename):
                search(full_filename) # 재귀 호출!
            else:
                ext = os.path.splitext(full_filename)[-1]
                if ext == '.py':
                    print(full_filename)
    except PermissionError:
        pass # 권한 없는 폴더는 패스

search("c:/")

```

---

## 6. 하위 디렉터리 검색을 쉽게 해주는 `os.walk`

**문제:** 위에서 만든 복잡한 재귀 함수를 `os.walk`를 사용하여 간단하게 구현하시오.

### os.walk의 특징

* 시작 경로만 주면 알아서 하위 디렉터리까지 순회하는 **제너레이터**입니다.
* `(현재경로, 포함된디렉터리들, 포함된파일들)` 형태의 튜플을 반환합니다.

### 코드 구현

```python
import os

for (path, dir, files) in os.walk("c:/"):
    for filename in files:
        ext = os.path.splitext(filename)[-1]
        if ext == '.py':
            # path와 filename을 합쳐서 출력
            print("%s/%s" % (path, filename))

```

> **결론:** 복잡한 파일 탐색 로직이 필요할 때는 직접 구현하는 것보다 **`os.walk`**라는 표준 라이브러리를 쓰는 것이 훨씬 효율적입니다.