---
layout: post
title: "02-20: 명령어 사이클과 인터럽트의 정밀 메커니즘"
date: 2026-02-20
categories: [Computer, Computer_Architecture]
tags: [Computer_Architecture, Instruction_Cycle, Interrupt, Addressing_Mode]
---

CPU가 하나의 명령어를 처리하는 정형화된 시간적 흐름을 **명령어 사이클(Instruction Cycle)**이라 하며, 이 흐름이 특정 신호에 의해 일시 중단되는 현상을 **인터럽트(Interrupt)**라고 합니다.

## 1. 명령어 사이클 (Instruction Cycle)

CPU는 메모리에서 명령어를 가져와 실행하는 주기를 반복하며 프로그램을 처리합니다. 이 주기는 데이터의 위치를 찾는 방식에 따라 추가적인 단계를 거치기도 합니다.

### ① 인출 사이클 (Fetch Cycle)
메모리에 있는 명령어를 CPU 내부의 **명령어 레지스터(IR)**로 가져오는 단계입니다. 프로그램 카운터(PC)는 다음 명령어의 주소로 업데이트됩니다.

### ② 간접 사이클 (Indirect Cycle)
인출한 명령어의 **오퍼랜드 필드(Operand Field)**에 담긴 주소가 실제 데이터의 위치가 아닌, '데이터의 주소가 저장된 또 다른 주소'일 때 발생합니다. 

* **간접 주소 지정 방식 (Indirect Addressing Mode):** 명령어의 비트 수가 제한적일 때 더 넓은 주소 공간을 활용하기 위해 사용합니다. 오퍼랜드 필드가 가리키는 주소로 이동하여 그곳에 적힌 **유효 주소(Effective Address)**를 다시 한 번 읽어와야 합니다. 
* **결과:** 메모리 참조가 최소 두 번 이상 발생하므로 인출 사이클과 실행 사이클 사이에 별도의 '간접 사이클'이 추가되어 실행 속도에 영향을 줍니다.
* **비유:** 보물찾기 쪽지를 찾았는데(인출), 오퍼랜드 필드(쪽지 내용)에 "보물은 나무 밑에 있다"가 아니라 "보물 지도는 교탁 안에 있다"라고 적힌 상황입니다. 진짜 보물(데이터)의 위치를 알기 위해 교탁(메모리)으로 한 번 더 가서 유효 주소(보물 지도)를 확인해야 하는 과정이 간접 사이클입니다.



### ③ 실행 사이클 (Execute Cycle)
해석된 명령어를 바탕으로 실제 연산을 수행하는 단계입니다. 제어장치가 제어 신호를 발생시켜 ALU와 레지스터들을 구동하며 작업을 완료합니다.

---

## 2. 인터럽트 (Interrupt)

인터럽트는 정상적인 실행 흐름을 가로채는 신호로, 발생 원인에 따라 동기와 비동기로 구분됩니다.

### ① 동기 인터럽트 (예외, Exception)
CPU가 명령어를 실행하던 중 내부적인 문제로 인해 스스로 발생시키는 신호입니다.
* **폴트 (Fault):** 예외 처리 후 예외가 발생한 그 명령어부터 다시 시작합니다. (예: 페이지 폴트)
* **트랩 (Trap):** 예외 처리 후 그 다음 명령어부터 실행합니다. (예: 디버깅용 중단점)
* **중단 (Abort):** 실행 불가능한 심각한 하드웨어 결함 시 발생하며 강제 종료됩니다.

### ② 비동기 인터럽트 (하드웨어 인터럽트)
주로 입출력 장치에 의해 발생하며, CPU에게 특정 작업의 완료나 상태 변화를 알립니다.
* **비유:** 세탁기나 전자레인지의 조리 완료 알림과 같습니다. CPU가 입출력 장치의 작업이 끝날 때까지 대기하지 않고 자기 할 일을 하다가, 알림이 오면 그때 처리하여 시스템 효율을 극대화합니다.

---

## 3. 하드웨어 인터럽트의 정밀 처리 순서

입출력 장치의 인터럽트 요청 시 CPU는 다음의 절차를 거쳐 대응합니다.

| 단계 | 상세 매커니즘 |
| :--- | :--- |
| **1. 인터럽트 요청 신호** | 입출력 장치가 전용 라인을 통해 CPU에 인터럽트 요청 신호를 보냅니다. |
| **2. 인터럽트 플래그 확인** | 매 사이클 종료 시 플래그 레지스터를 확인합니다. 비마스커블(NMI)은 즉시 수용하고, 마스커블은 플래그가 활성화된 경우에만 처리합니다. |
| **3. 문맥 저장 (Context Save)** | 복귀 지점을 기억하기 위해 **프로그램 카운터(PC)**와 레지스터 상태 정보를 **스택(Stack)** 영역에 임시 저장합니다. |
| **4. 인터럽트 벡터 참조** | 인터럽트 벡터 테이블에서 요청 장치에 해당하는 **인터럽트 서비스 루틴(ISR)**의 시작 주소를 찾아냅니다. |
| **5. 서비스 루틴 실행** | 특정 장치를 제어하거나 데이터를 수집하는 인터럽트 핸들러 코드를 실행합니다. |
| **6. 문맥 복구 및 복귀** | 스택에 저장했던 원래의 PC 값 등을 복구하여 중단되었던 명령어부터 실행을 재개합니다. |



---

## 4. 보강

* **인터럽트 서비스 루틴 (ISR):** 인터럽트 발생 시 이를 해결하기 위해 메모리에 미리 상주하는 프로그램 코드입니다.
* **인터럽트 벡터 (Interrupt Vector):** 다양한 인터럽트 요청에 대응하는 각 루틴의 시작 주소를 담고 있는 일종의 주소록입니다.
* **유효 주소 (Effective Address):** 주소 지정 방식을 통해 최종적으로 도달하게 되는, 실제 연산 데이터가 저장된 메모리 주소입니다.
* **디버깅 (debugging) :** 디버깅이란 프로그램 개발 중에 발생한 문제를 진단하고 해결 하기 위한 작업을 의미합니다.