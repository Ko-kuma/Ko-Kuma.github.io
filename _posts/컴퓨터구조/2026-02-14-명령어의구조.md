---
layout: post
title: "명령어의 구조, 연산 코드와 오퍼랜드, 주소 지정 방식"
date: 2026-02-14
categories: [Computer, Computer_Architecture]
tags: [Computer_Architecture, Opcode, Operand, Addressing_Mode]
---

명령어는 '무엇을 대상으로 어떤 동작을 수행하라'는 메시지입니다. 이 구조를 뜯어보면 **연산 코드**와 **오퍼랜드**로 나뉩니다.

## 1. 연산 코드(Opcode)와 오퍼랜드(Operand)

* **연산 코드**: 명령어가 수행할 연산(연산자)입니다.
    * 예: 더해라, 빼라, 저장하라.
    * 연산 코드가 담기는 영역을 **연산 코드 필드**라고 합니다.
* **오퍼랜드**: 연산에 사용할 데이터 또는 데이터가 저장된 위치(피연산자)입니다.
    * 오퍼랜드 필드에는 실제 데이터(숫자, 문자 등)보다 **메모리 주소나 레지스터 이름**이 더 자주 담기기 때문에 **주소 필드**라고도 부릅니다.
    * 어셈블리어 예시: `push(연산코드) rbp(오퍼랜드)`.

### 주소 명령어의 분류
오퍼랜드 필드의 개수에 따라 명령어를 분류합니다.
* **0-주소 명령어**: 오퍼랜드 없이 연산 코드만 존재합니다.
* **1-주소 명령어**: 오퍼랜드가 1개인 명령어입니다.
* **2-주소 / 3-주소 명령어**: 오퍼랜드가 각각 2개, 3개인 명령어입니다.

---

## 2. 연산 코드의 4가지 주요 종류

CPU마다 종류가 다양하지만, 대표적으로 다음 4가지는 공통적으로 이해합니다.

| 분류 | 주요 연산 및 설명 |
| :--- | :--- |
| **데이터 전송** | **MOVE**(데이터 이동), **STORE**(메모리 저장), **LOAD**(메모리 읽기), **PUSH/POP**(스택 작업). |
| **산술/논리 연산** | **ADD/SUB/MUL/DIV**(사칙연산), **INCREMENT/DECREMENT**(1증가/감소), **AND/OR/NOT**(논리연산), **COMPARE**(두개의 숫자, TRUE/FALSE 비교) |
| **제어 흐름 변경** | **JUMP**(특정 주소로 실행 순서 이동), **CONDITIONAL JUMP**(조건부 이동), **HALT**(실행 중지), **CALL**(되돌아올 주소를 저장, 특정 주소로 실행 순서 이동), **RETURN**(CALL을 호출 할 때 저장한 주소로 돌아가기) |
| **입출력 제어** | **READ/WRITE**(입출력 장치 데이터 읽기/쓰기), **START/TEST IO**(입출력 시작/상태 확인). |

---

## 3. 주소 지정 방식 (Addressing Modes)

오퍼랜드 필드에 왜 실제 데이터 대신 '주소'를 넣을까요? 명령어가 가질 수 있는 **비트 수의 한계** 때문입니다. (예: 16비트 명령어 중 연산 코드가 4비트라면, 오퍼랜드 하나당 쓸 수 있는 비트가 매우 적어 큰 숫자를 직접 넣을 수 없습니다.)



* **유효 주소(Effective Address)**: 연산에 사용할 데이터가 실제로 저장된 위치(주소)입니다.
* **주소 지정 방식**: 오퍼랜드 필드에 담긴 정보를 이용해 유효 주소를 찾는 방법입니다.

### 대표적인 주소 지정 방식
1.  **즉시 주소 지정**: 오퍼랜드 필드에 **실제 데이터**를 직접 명시합니다. 주소를 거치지 않아 빠르지만 데이터 크기 제한이 있습니다.
2.  **직접 주소 지정**: 오퍼랜드 필드에 **유효 주소(메모리 주소)**를 직접 명시합니다. 주소 공간은 넓어지나 여전히 명령어 비트 수의 제약을 받습니다.
3.  **간접 주소 지정**: 오퍼랜드 필드에 **유효 주소의 주소**를 담습니다. 메모리를 두 번 거치므로 느리지만 매우 넓은 주소 공간을 사용할 수 있습니다.
4.  **레지스터 주소 지정**: 연산에 사용할 데이터가 저장된 **레지스터 이름**을 명시합니다. 메모리보다 훨씬 빠른 레지스터에 접근합니다.
5.  **레지스터 간접 주소 지정**: 연산에 사용할 데이터는 메모리에 있고, 그 **메모리의 유효 주소를 레지스터에 저장**해둔 방식입니다.

---

## 4. 자료구조의 기초: 스택(Stack)과 큐(Queue)

명령어 실행과 데이터 관리에서 자주 쓰이는 기본 구조입니다.

* **스택 (Stack)**
    * **LIFO (Last-In-First-Out)**: 나중에 들어온 데이터가 가장 먼저 나가는 '후입선출' 구조입니다.
    * **PUSH**: 데이터를 스택에 집어넣는 작업입니다.
    * **POP**: 스택에서 데이터를 꺼내는 작업입니다.
* **큐 (Queue)**
    * **FIFO (First-In-First-Out)**: 먼저 들어온 데이터가 가장 먼저 나가는 '선입선출' 구조입니다.

---
## 정리 
* 명령어는 연산코드와 오퍼랜드의 구성
* 연산코드는 명령어가 수행할 연산
* 오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치
* 주소지정방식은 연산에 사용할 데이터 위치를 찾는 방법